\chapter{Materials and Methods}

This section is to clarify the pre-existing tools, defining what was developed in this field until now, and why this tool was used instead of others.

The general structure is the following:
\begin{itemize}
	\item Definition of the specific tool(s) studied (robots, sensor nodes, smart-phones). When relevant, pre-existing experiments.
	\item Definition of the context of use (indoor/outdoor, humans/animals/robots, with/without connection).
	\item Definition of used protocols (How the data are collected, when, etc.)
\end{itemize}

\section{Wireless Sensor Networks}
-A wireless sensor networks are a collection of small, low-cost, low-power and multifunctional sensor nodes.
-Able to communicate with each other. 
-Placed to monitore an area of intrest.
-Constrains.	
-Multi hop network not multi hop networks
-Stuff to take care of because of constrains

TinyOS: An Operating System for Sensor Networks:
-Consists of potentialy thousands of nodes
-small, flexible, lowcost nodes that interact with their environment
-applications ranging from environmental and habitat monitoring [11, 51], seismic analysis of structures [10], and object localization and tracking [68].


\section{Radio Tomographic Imaging}
Radio Tomographic Imaging(RTI) is a method to localize people inside an area covered by a WSN. To do so the WSN monitors the received signal strength(RSS) of each link inside the network by letting each node send messages over radio in broadcast. Whenever a person stays or moves inside the monitored area it affects RSS of some or all links. The changes can then be processed and a position of the person can be estimated. This makes it possible to localise a person without it having to carry any device \cite{RtiMulti}.
\section{Multi-Spin}
When monitoring the RSS of each link inside a WSN it is important to take into account that not only changes inside the environment can effect the RSS. Also multiple messages send at the same time will interfere with each other and distort the measured change of the RSS. To counteract this a methode to schedule the messages in a way that only one node sends at a given point in time is needed. The literature suggest the Multi-Spin spin algorithm that defines for each node a point in time when it should send its message.

In Multi-Spin time is divided into $slots$ and $cycles$ where a $cycle$ is the time all the nodes need to send one message each. Then a $cycle$ is divided by the number of nodes inside the network resulting in one $slot$ for each node, shown in Figure \ref{fig:multi}. Now each node will send in one of these slots. The order in which the nodes send is defined by their ID. To make this possible the nodes need to somehow synchronize at the beginning. Therefore each node will send messages. When the first message is received the nodes will synchronize themselves with that message and start sending in the order of their IDs. Whenever a node receives a message it can calculate the time until the next $cycle$, so the nodes stay synchronized all the time.  \cite{RtiMulti}

\begin{figure}[htbp]
	\centering
    \includegraphics[scale=0.8]{content/images/Multispin}
   	\caption{Time is  \cite{RtiMulti}}
    \label{fig:multi}
\end{figure}

For the collection of the RSS measurements a extra node that overhears all the messages is connected to a PC. The nodes will include their ID and the last RSS measurements inside their messages. The extra node now receives the messages from all the other nodes and forward them to the PC.  \cite{RtiMulti}

This methode is realy fast, efficient and stable. However it only works under the assumption that all the nodes can hear each other. When not all the nodes hear each other the synchronization would not be that accurate making it necessary to resynchronize for each circle. Moreover the data collection does not work at all since there is no node that is able to hear all the other nodes and therefore collect the information by simply listening to the send messages.
Therefore a different method is needed for a widely spread multi hop network.

%should be explained in more detail
%very short time because highly optimized without a real time os benethe it
%not possible inside a multi hop enviroment
%every round needs a time sinchronization
%data collection not possible like that
%very cool but not sufficient in a multi hop enviroment
 
\section{Testbed}
The Testbed is a WSN located on the third floor of the SA building at the University of Duisburg-Essen. It is set up as a tool for researches on WSNs in an indoor environment. It covers half of the building including a large main corridor, two laboratories, two smaller corridors leading to three offices each, seven smaller storage rooms and one server room. The arrangement of the rooms is laid out in Figure \ref{fig:testbed}. All in all the area covers $531m^2$. All the rooms are in daily use by the people working in the offices and the laboratories keeping the area under constant change.

\begin{figure}[htbp]
	\centering
    \includegraphics[scale=0.75]{content/images/Testbed}
   	\caption{Floor plan of the area where the Testbed is located. The position of the nodes is shown by the numbered antennas.}
    \label{fig:testbed}
\end{figure}

To monitor the area 32 nodes are distributed over the rooms like shown in Figure \ref{fig:testbed}. The nodes are only placed inside the offices and laboratories and are not always placed at the same hight. To make programming of the devices easy all the devices are connected to Raspberry Pies via USB. A script then makes it possible to copy the source code to all the Raspberry Pies where the code is compiled and then send to each node individual. The connection to the Raspberry Pies makes it also possible to collect information directly from each node individually over serial forwarder running on the Raspberry Pies.

\subsection{TelosB Mote}
The sensor nodes used for the Testbed are Crossbow's TelosB Motes TPR2420. The TPR2420 is a open source platform for researchers developed by the University of California, Berkley. It provides a 8 MHz Texas Instrument MSP430 low power microcontroller with 10kB RAM that is programmable via a USB connector. For communication it includes a IEEE 802.15.4 compliant radio frequency transceiver with an embedded antenna. This makes transmissions in a frequency band from 2.4 to 24835 GHz possible. Moreover the TPR2420 has a light sensor, a Infra-Red sensor, a humidity sensor and a temperature sensor installed making it possible to monitor the environment. Last it has three led lights installed that can be used for visual output of the mote. The USB connector that can be used to program the microcontroller can also be used to exchange data with and to power the TPR2420. If it is not connected via USB it can also be powered by two AA batteries. \cite{telosb}

\begin{figure}[htbp]
	\centering
    \includegraphics[scale=0.7]{content/images/Mote1}
   	\caption{The structure of the TPR2420 and the included components \cite{telosb}}
    \label{fig:telosb}
\end{figure}
 
\subsection{TinyOs}
TinyOS is an operating system for embedded systems, designed to manage the limited resources and power and to provide reactive concurrency and flexibility. It is widely used by multiple research groups ans companies world wide to support their applications.

The main tasks of TinyOS is to schedule tasks and events to provide safe concurrent operations. However it also provides a large amount of reusable system components, like timers, sender or receiver, that provide a huge variety of functionalities. When compiling a application only the TinyOS components that are used are included into the application creating an application-specific OS.

To provide functionality each component can have three different types of computational abstractions. First commands, then events than tasks.

flexible, application-specivic operation system for wireless sensor networks
supports complex yet safe concurrent operations
for sensor network research;
Over one hundred groups worldwide use it, including several companies within their products
and research topics
core OS is 400 bytes

Four broad requirements motivate the design of TinyOS:
Limited resources
Reactive Concurrency
Flexibility
Low Power

TinyOS supports an event-driven concurrency model based on split-phase interfaces, asynchronous events, and deferred computation called tasks. TinyOS is implemented in the NesC language.

TinyOS is not an OS in the traditional sense; it is a programming framework for embedded systems and set of components that enable building an application-specific OS into each application

TinyOS program is a graph of components, each of which is an independent computational entity that exposes one or more interfaces. Components have three computational abstractions: commands, events, and tasks. Commands and events are mechanisms for intercomponent communication, while tasks are used to express intra-component concurrency.

The standard TinyOS task scheduler uses a non-preemptive, FIFO scheduling policy

TinyOS itself simply consists of a set of reusable system components along with a task scheduler.
